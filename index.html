<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>‡∏û‡∏π‡∏î ‚Üí ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÉ‡∏´‡∏ç‡πà</title>

<meta name="theme-color" content="#000000">
<meta name="apple-mobile-web-app-capable" content="yes">

<style>
body{
  margin:0;
  background:black;
  color:white;
  font-family:system-ui,sans-serif;
  height:100vh;
  display:flex;
  flex-direction:column;
}
#text{
  flex:1;
  display:flex;
  align-items:center;
  justify-content:center;
  text-align:center;
  padding:24px;
  font-size:96px;
  line-height:1.25;
  word-break:break-word;
}
#status{
  text-align:center;
  font-size:36px;
  font-weight:bold;
  color:#00ff00;
  padding:10px;
  display:none;
}
.controls{
  padding:16px;
}
button{
  width:100%;
  font-size:36px;
  padding:26px;
  border:none;
  border-radius:20px;
  font-weight:bold;
}
#mic{
  background:#1db954;
  color:black;
}
</style>
</head>

<body>

<div id="text"></div>
<div id="status">üé§ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ü‡∏±‡∏á‚Ä¶ <span id="timer">00:00</span></div>

<div class="controls">
  <button id="mic">‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏û‡∏π‡∏î</button>
</div>

<script>
/* ===== CONFIG ===== */
const WAIT_MS = 10000; // ‡∏£‡∏≠‡πÄ‡∏™‡∏µ‡∏¢‡∏á 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ

/* ===== ELEMENTS ===== */
const textDiv = document.getElementById("text");
const statusDiv = document.getElementById("status");
const timerSpan = document.getElementById("timer");
const micBtn = document.getElementById("mic");

/* ===== SPEECH ===== */
const SpeechRecognition =
  window.SpeechRecognition || window.webkitSpeechRecognition;

const recog = new SpeechRecognition();
recog.lang = "th-TH";
recog.continuous = true;
recog.interimResults = false;

/* ===== STATE ===== */
let listening = false;
let seconds = 0;
let blinkInterval, timeInterval, autoStopTimer;

/* ===== UTILS ===== */
function fmt(sec){
  const m = String(Math.floor(sec/60)).padStart(2,"0");
  const s = String(sec%60).padStart(2,"0");
  return `${m}:${s}`;
}

/* ===== BUTTON ===== */
micBtn.onclick = () => {
  listening ? stopListen() : startListen();
};

function startListen(){
  listening = true;
  recog.start();
}

function stopListen(){
  listening = false;
  clearTimeout(autoStopTimer);
  recog.stop();
}

/* ===== EVENTS ===== */
recog.onstart = () => {
  micBtn.innerText = "‚èπÔ∏è ‡∏´‡∏¢‡∏∏‡∏î";
  micBtn.style.background = "#ff5252";

  seconds = 0;
  timerSpan.innerText = "00:00";
  statusDiv.style.display = "block";

  blinkInterval = setInterval(() => {
    statusDiv.style.visibility =
      statusDiv.style.visibility === "hidden" ? "visible" : "hidden";
  }, 800);

  timeInterval = setInterval(() => {
    seconds++;
    timerSpan.innerText = fmt(seconds);
  }, 1000);

  resetAutoStop();
};

recog.onresult = (e) => {
  const txt = e.results[e.results.length-1][0].transcript.trim();

  // ‡∏û‡∏π‡∏î 1 ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ = ‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏´‡∏°‡πà
  textDiv.innerText = txt;

  resetAutoStop();
};

recog.onend = () => {
  clearInterval(blinkInterval);
  clearInterval(timeInterval);

  if (listening) {
    // Speech API ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏≠‡∏á ‚Üí ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
    setTimeout(() => recog.start(), 300);
    return;
  }

  // ‡∏´‡∏¢‡∏∏‡∏î‡∏à‡∏£‡∏¥‡∏á
  micBtn.innerText = "‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏û‡∏π‡∏î";
  micBtn.style.background = "#1db954";
  statusDiv.style.display = "none";
  statusDiv.style.visibility = "visible";
};

/* ===== AUTO STOP ===== */
function resetAutoStop(){
  clearTimeout(autoStopTimer);
  autoStopTimer = setTimeout(() => {
    stopListen();
  }, WAIT_MS);
}

/* ===== PWA (‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏î‡∏µ‡∏¢‡∏ß) ===== */
if ("serviceWorker" in navigator) {
  const swCode = `
    self.addEventListener('install',e=>{
      e.waitUntil(
        caches.open('talk-pwa').then(c=>c.addAll(['./']))
      );
    });
    self.addEventListener('fetch',e=>{
      e.respondWith(
        caches.match(e.request).then(r=>r||fetch(e.request))
      );
    });
  `;
  const blob = new Blob([swCode], {type:"text/javascript"});
  navigator.serviceWorker.register(URL.createObjectURL(blob));
}
</script>

</body>
</html>
